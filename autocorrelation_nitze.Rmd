---
title: "autocorrelation_nitze"
author: "Margo Moceyunas"
date: "2024-07-16"
output: html_document
---
## Load library and dataset
```{r}
library(sf)
library(ggplot2)
library(spatstat)
library(nngeo)
library(tidyverse) # I always load this last, because my assumption is that I want to make sure that the tidyverse version of functions with conflicts is the default one, since I use the tidyverse so much
```

```{r}
nitze_sf <- st_read("../ARTS_supporting_files/nitze_negative_data_splitting/nitzeTrainingLabel2023_Negative_meta3.shp")
arts_sf = st_read("../rts_rep_analysis/pca/arts_pc_v.1.0.0.geojson")
```

## Set up 
```{r make valid}
if (!all(st_is_valid(arts_sf))) {
  arts_sf = st_make_valid(arts_sf)
}
```

Simplify the many overlapping polygons in the Nitze BBox dataset
```{r}
nitze_simple = nitze_sf |>
  st_remove_holes() |>
  st_union() |>
  st_cast('POLYGON') |>
  st_as_sf()
```

```{r}
ggplot() + 
  geom_sf(data = nitze_sf, 
          color = 'red',
          fill = 'transparent',
          linewidth = 0.2) +
  geom_sf(data = nitze_simple, 
          color = 'black',
          fill = 'transparent',
          linewidth = 0.2)

ggplot() + 
  geom_sf(data = nitze_sf, 
          color = 'red',
          fill = 'transparent',
          linewidth = 0.2) +
  geom_sf(data = nitze_simple, 
          color = 'black',
          fill = 'transparent',
          linewidth = 0.2) +
  # coord_sf(datum = 3413) # used this to figure out the limits for the zoom below, because ggplot automatically displays lat and lon lines even when the crs of the input data uses a non-degree unit
  coord_sf(
    xlim = c(-2.8e+06, -2e+06), # zoom limits given in units of crs of data
    ylim = c(-5e+05, 1e+06)
  )
```

```{r intersection}
arts_nitze = arts_sf |>
  filter(
    map_lgl(
      st_intersects(arts_sf, nitze_simple, sparse = TRUE), 
      ~ length(.x) > 0
    )
  )
```

```{r}
ggplot() + 
  geom_sf(data = nitze_simple,
          aes(color = 'Nitze BBoxes',
              fill = 'Nitze BBoxes')) + 
  geom_sf(data = arts_nitze, 
           aes(color = 'ARTS',
               fill = 'ARTS'),
          size = 0.2) +
  scale_color_manual(name = 'Dataset',
                     values = c('red', 'black')) +
  scale_fill_manual(name = 'Dataset',
                     values = c('transparent', 'transparent')) +
  theme(legend.position = 'bottom')

ggplot() + 
  geom_sf(data = nitze_simple,
          aes(color = 'Nitze BBoxes',
              fill = 'Nitze BBoxes')) + 
  geom_sf(data = arts_nitze, 
           aes(color = 'ARTS',
               fill = 'ARTS'),
          size = 0.2) +
  scale_color_manual(name = 'Dataset',
                     values = c('red', 'black')) +
  scale_fill_manual(name = 'Dataset',
                     values = c('transparent', 'transparent')) +
  coord_sf(
    xlim = c(-2.8e+06, -2e+06), # zoom limits given in units of crs of data
    ylim = c(-5e+05, 1e+06)
  )
```

```{r convert to points}
arts_nitze_w_points = arts_nitze |>
    mutate(
        centroid_geometry = map2(
            as.numeric(CentroidLon),
            as.numeric(CentroidLat),
            ~ st_point(c(.x, .y))
            ) |>
            st_sfc(crs = 4326) |> # because the centroid points are reported in wgs 84
            st_transform(crs = 3413) # assuming you want the output to match the CRS of ARTS as a whole
        )
```

```{r create centroids and ppp}
centroids_sf <- arts_nitze_w_points$centroid_geometry
centroids_sf <- as.data.frame(centroids_sf)
centroids
centroids_ppp <- as.ppp(centroids$geometry)
```

## Average nearest neighbor
```{r first and second nearest neighbor distance in ?? units}
mean(nndist(centroids_ppp, k=1))
mean(nndist(centroids_ppp, k=2))
```

```{r ann vs neighbor order plot}
ANN <- apply(nndist(centroids_ppp, k=1:7257),2,FUN=mean)
plot(ANN ~ eval(1:7257), type="b", main=NULL, las=1)
```
## Hypothesis Test
```{r assuming uniform point density across the nitze region}
ann.p <- mean(nndist(centroids_ppp, k=1))
ann.p
```

```{r convert nitze_sf to owin polygon layer of boundaries?}
nitze_owin <- as.owin(nitze_sf)
class(nitze_owin)
plot(nitze_owin)
```

```{r null model}
n     <- 1L               # Number of simulations
ann.r <- vector(length = n) # Create an empty object to be used to store simulated ANN values
for (i in 1:n){
  rand.p   <- rpoint(n=centroids_ppp$n, win=nitze_owin)  # Generate random point locations
  ann.r[i] <- mean(nndist(rand.p, k=1))  # Tally the ANN values
}
plot(rand.p, pch=16, main=NULL, cols=rgb(0,0,0,0.5))
```